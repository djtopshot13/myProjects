
    MyLeague.py
    
    #**I should make a new module for matchups and put the functions and data stats inside the class/object to make it easier to read the code
    # and have the code encapsulated better than what it is currently

    # set up matchup results print method 
    # prints winning team name, losing team name, and the point margin that was won by
    # def printWeekMatchupResults(self, weekNum, winning_teams, winning_scores, losing_teams, losing_scores, score_deficits):
    #     matchups = self.matchups[weekNum] # get the matches of the week using the weekNum parameter
    #     # print(f"\nWeek {weekNum} Matchup Results: \n") # print header with which week is being represented
        

    #     for i in range(len(self.teams) // 2): # Iterate over the number of matches per week which should be 4 in this 8 team league
    #         curr_matchup = matchups[i] # use the week matchups and iterate from 0-3 to get all 4 matchups
    #         # set if else case to determine winning team based on being home or away since that's how the matchup object is set up
    #         # if home team wins
    #         if (curr_matchup.home_score > curr_matchup.away_score):
    #             # winning team and winning score -> home team name and home team score
    #             # losing team and losing score -> away team name and away team score
    #             winning_team = curr_matchup.home_team.team_name
    #             winning_score = curr_matchup.home_score
    #             losing_team = curr_matchup.away_team.team_name
    #             losing_score = curr_matchup.away_score
                

    #         # else away team wins
    #         else:
    #             # winning team and winning score -> away team name and away team score
    #             # losing team and losing score -> home team name and home team score
    #             winning_team = curr_matchup.away_team.team_name
    #             winning_score = curr_matchup.away_score  
    #             losing_team = curr_matchup.home_team.team_name
    #             losing_score = curr_matchup.home_score

    #         # set up point margin by getting the difference between winning and losing score rounded to 1 decimal place
    #         score_deficit = round(winning_score - losing_score, 1)

    #         winning_teams[weekNum-1].append(winning_team)
    #         winning_scores[weekNum-1].append(winning_score)
    #         losing_teams[weekNum-1].append(losing_team)
    #         losing_scores[weekNum-1].append(losing_score)
    #         score_deficits[weekNum-1].append(score_deficit)

            
            # print statement with winning team, winning score [win message] losing team and losing score with point margin
            # print(f"{winning_team}({winning_score} pts) won against {losing_team}({losing_score} pts) by {score_deficit} pts \n")

        # **Use this for possibly creating a win/loss streak report and maximum/minimum score differentials by week
        # Rewrite the stats function to be used in the season matchup results by using return values from the weekly results to access the winning team and losing team info
        # self.weeklyMatchupStats(matchup_map)
        # return matchup_map
        # return winning_teams, winning_scores, losing_teams, losing_scores, score_deficits 
        # winning_list, losing_list, score_deficit_list

    # Finding more unique stats from the week to maybe consolidate reporting on the matchups
    # def weeklyMatchupStats(self, team_record_map, full_matchup_map, winning_scores, losing_scores, score_deficits):
        # team_record_map["streak"] = {team: "" for team in self.teams}

        # matchup_period = self.curr_matchup_period - 1 # account for current week being played and not finalized
        
        # for team in self.teams:
        #     prev_val = 0
        #     streak_count = 0  

        #     for index in range(matchup_period - 1, -1, -1):
        #         curr_val = team_record_map[team][index]
        #         if prev_val == curr_val:
        #             streak_count += 1

        #         elif prev_val == 0:
        #             prev_val = curr_val
        #             streak_count += 1

        #         else:
        #             team_record_map['streak'][team] = prev_val + str(streak_count)
        #             break
        
        # print()
        # print(team_record_map)
        # highest_winning_scores = [] # overall highest score of each week in list with index of weekNum - 1
        # lowest_winning_scores = [] # lowest scores yet winning by week with index of weekNum - 1
        # highest_losing_scores = [] # highest scores yet losing by week with index of weekNum - 1
        # lowest_losing_scores = [] # overall lowest score of each week in list with index of weekNum - 1
        # smallest_score_deficits = [] # smallest point deficit of each week in list with index of weekNum - 1
        # largest_score_deficits = [] # largest point deficit of each week in list with index of weekNum - 1
        # highest_winning_teams = []
        # highest_losing_teams = []
        # lowest_winning_teams = []
        # lowest_losing_teams = []
        # highest_deficit_winning_teams = []
        # highest_deficit_losing_teams = []
        # lowest_deficit_winning_teams = []
        # lowest_deficit_losing_teams = []

        # for index in range(1, self.curr_matchup_period):
        #     matchup_idx = 0
        #     key_val = 'Week ' + str(index)

            # highest_winning_scores.append(max(winning_scores[index-1]))
            # matchup_idx = winning_scores[index-1].index(highest_winning_scores[index-1]) + 1
            # match_val = 'Matchup ' + str(matchup_idx)
            # highest_winning_teams.append(full_matchup_map[key_val][match_val][0]['winning_team'])

            # # teams, winners = matchup_map['winning_scores'][index].items()
            # lowest_winning_scores.append(min(winning_scores[index-1]))
            # matchup_idx = winning_scores[index-1].index(lowest_winning_scores[index-1]) + 1
            # match_val = 'Matchup ' + str(matchup_idx)
            # lowest_winning_teams.append(full_matchup_map[key_val][match_val][0]['winning_team'])

            # highest_losing_scores.append(max(losing_scores[index-1]))  
            # matchup_idx = losing_scores[index-1].index(highest_losing_scores[index-1]) + 1
            # match_val = 'Matchup ' + str(matchup_idx)
            # highest_losing_teams.append(full_matchup_map[key_val][match_val][1]['losing_team'])

            # lowest_losing_scores.append(min(losing_scores[index-1]))  
            # matchup_idx = losing_scores[index-1].index(lowest_losing_scores[index-1]) + 1
            # match_val = 'Matchup ' + str(matchup_idx)
            # lowest_losing_teams.append(full_matchup_map[key_val][match_val][1]['losing_team'])

            # largest_score_deficits.append(max(score_deficits[index-1]))  
            # matchup_idx = score_deficits[index-1].index(largest_score_deficits[index-1]) + 1
            # match_val = 'Matchup ' + str(matchup_idx)
            # highest_deficit_winning_teams.append(full_matchup_map[key_val][match_val][0]['winning_team'])
            # highest_deficit_losing_teams.append(full_matchup_map[key_val][match_val][1]['losing_team'])

            # smallest_score_deficits.append(min(score_deficits[index-1]))  
            # matchup_idx = score_deficits[index-1].index(smallest_score_deficits[index-1]) + 1
            # match_val = 'Matchup ' + str(matchup_idx)
            # lowest_deficit_winning_teams.append(full_matchup_map[key_val][match_val][0]['winning_team'])
            # lowest_deficit_losing_teams.append(full_matchup_map[key_val][match_val][1]['losing_team'])
    
        
    
        # figure out how to get this to work later
        # teams, streaks = matchup_map['streak'].items()
        
        # return highest_winning_scores, lowest_winning_scores, highest_losing_scores, lowest_losing_scores, largest_score_deficits, smallest_score_deficits
                



   # not sure if this is used 
    # I think I was trying to format the team record results 
    # and use this instead to print the standings
    # Check on this another time 

    # def LeagueRecord(self):
    #     for team in self.teams.values():
    #         self.titleFormat(team)
    #         team.displayTeamRecord()
    #         print()


          # self._all_players = self._get_All_Players()
        
    # I don't think I need this method any more since there's already one in the regular League file now
    # def _get_Rostered_Players(self):
    #     rostered_players = []
    #     for team in self.teams.values():
    #         for player in team.players:
    #             rostered_players.append(player)
    #     return rostered_players
    
    # I don't know if I need to refactor this and see if I can get the unrostered players since I get free agents in the other League as well.
    # def _get_Unrostered_Players(self):
    #     my_team = self.teams["Dillon's Dubs"]
    #     unrostered_players = _construct_Available_Players(_get_Available_Players())
    #     return unrostered_players

    ## Streak Method Code

     # first_degree = [player for player in first_degree if isinstance(player, tuple)]
        # second_degree = [player for player in second_degree if isinstance(player, tuple)]
        # third_degree = [player for player in third_degree if isinstance(player, tuple)]

        # full_2nd = [
        #     p2 for (p2, _) in just_2nd
        #     if any(p2 == p1 for (p1, _) in just_1st)
        # ]

        # full_3rd = [
        #     p3 for (p3, _) in just_3rd 
        #     if any(p3 == p2 for (p2, _) in full_2nd) 
        # ]

        # full_3rd_full_2nd_consistent_1st = [
        #     p3 for (p3, _) in just_3rd 
        #     if any(p3 == p2 for (p2, _) in full_2nd) 
        #     and any(p3 == p1 for (p1, _) in consistent_1st)
        # ]

        # games_played_7 = player.last_7_dict.get('GP', 0)
        # points_7 = player.last_7_dict.get('PTS', 0)
        # avg_points_7 = round(points_7 / games_played_7, 1) if games_played_7 != 0  else 0
        # if avg_points_7 > avg_points_total:
        #     avg_points_increase = avg_points_7 - avg_points_total
        #     first_degree[index] = (player, avg_points_increase)
        #     player_report[player][0].append("Full")
        # elif avg_points_7 == avg_points_total:
        #     consistent[0].append((first_degree.remove(player), avg_points_total))
        #     player_report[player][0].append("Consistent")
        # else:
        #     cold_streak[0].append((first_degree.remove(player), avg_points_total - avg_points_7))
        #     player_report[player][0].append("Cold")

        # games_played_15 = player.last_15_dict.get('GP', 0)
        # points_15 = player.last_15_dict.get('PTS', 0)
        # avg_points_15 = round(points_15 / games_played_15, 1) if games_played_15 != 0  else 0
        # if avg_points_15 > avg_points_total:
        #     avg_points_increase = avg_points_15 - avg_points_total
        #     second_degree[index] = (player, avg_points_increase)
        #     player_report[player][1].append("Full")
        # elif avg_points_15 == avg_points_total:
        #     consistent[1].append((player, avg_points_total))
        #     player_report[player][1].append("Consistent")
        #     # remove_second_degree.append(player)
        # else:
        #     cold_streak[1].append((player, avg_points_total - avg_points_15))
        #     player_report[player][1].append("Cold")
        #     remove_second_degree.append(player)


        # games_played_7 = player.last_7_dict.get('GP', 0)
        # points_7 = player.last_7_dict.get('PTS', 0)
        # avg_points_7 = round(points_7 / games_played_7, 1) if games_played_7 != 0  else 0
        # if avg_points_7 > avg_points_total:
        #     avg_points_increase = avg_points_7 - avg_points_total
        #     first_degree[index] = (player, avg_points_increase)
        #     player_report[player][0].append("Full")
        # elif avg_points_7 == avg_points_total:
        #     consistent[0].append((player, avg_points_total))
        #     player_report[player][0].append("Consistent")
        #     # remove_first_degree.append(player)
        # else:
        #     cold_streak[0].append((player, avg_points_total - avg_points_7))
        #     player_report[player][0].append("Cold")
        #     remove_first_degree.append(player)

        # for player in roster:
            # if player.last_7_dict.get('PTS', 0) != 0:
                #     first_degree.append(player)
                #     if player.last_15_dict.get('PTS', 0) != 0:
                #         second_degree.append(player)
                #         if player.last_30_dict.get('PTS', 0) != 0:
                #             third_degree.append(player)
        
        # consistent, cold_streak = [[] for _ in range(3)], [[] for _ in range(3)]
        # remove_first_degree, remove_second_degree, remove_third_degree = [], [], []

        # print("Full 3rd Degree Hot Streak:\n")
        # self.printStreakPlayers(full_hot_3rd)
        # print("Full 2nd Degree Hot Streak:\n")
        # self.printStreakPlayers(full_hot_2nd)
        # print("Full 1st Degree Hot Streak:\n")
        # self.printStreakPlayers(full_hot_1st)
        # print("Players Cooling Dwon:\n")
        # self.printStreakPlayers(cooling_down)
        # print("Players Heating Up:\n")
        # self.printStreakPlayers(heating_up)

        # full_hot_3rd = sorted(full_hot_3rd, key=lambda player: player.values()['avg_points'])
       
        # print("Full 2nd Degree Hot Streak:\n")
        # print(full_hot_2nd)
        # print()
        # print("Full 1st Degree Hot Streak:\n")
        # print(full_hot_1st)
        # print("\n\n")

        # print("Full 3rd Degree Conistent Streak:\n")
        # print(full_cons_3rd)
        # print()
        # print("Full 2nd Degree Conistent Streak:\n")
        # print(full_cons_2nd)
        # print()
        # print("Full 1st Degree Conistent Streak:\n")
        # print(full_cons_1st)
        # print("\n\n")
        
        # print("Full 3rd Degree Cold Streak:\n")
        # print(full_cons_3rd)
        # print()
        # print("Full 2nd Degree Cold Streak:\n")
        # print(full_cons_2nd)
        # print()
        # print("Full 1st Degree Cold Streak:\n")
        # print(full_cons_1st)
        # print("\n\n")

        # print("Players Trending Hot:\n")
        # print(heating_up)
        # print()
        # print("Players Trending Cold:\n")
        # print(cooling_down)
        # print("\n\n")

        # full_hot_3rd, full_hot_2nd, full_hot_1st, full_cons_3rd, full_cons_2nd, full_cons_1st, full_cold_3rd, full_cold_2nd, full_cold_1st =  [], [], [], [], [], [], [], [], []
        # heating_up, cooling_down = [], []
        # full_cold_3rd, full_cold_2nd, full_cold_1st, full_empty_2nd, full_empty_1st  = [], [], [], [], [] all empty are full 3rd degree and pointless

    # def hotStreakFullReport(self, team, first_degree, second_degree, third_degree, full_second_degree, full_third_degree, consistent):
    #     all_players = []
    #     if team:
    #         print(f"{team} Hot Streak Report:\n")

    #     print("Full 3rd Degree Hot Streak:\n")
    #     for player, increase_30 in full_third_degree:
    #         player_15 = next((p for p, inc in full_second_degree if p == player), None)
    #         player_7 = next((p for p, inc in first_degree if p == player), None)
    #         if player_15 and player_7:
    #             increase_15 = next(inc for p, inc in full_second_degree if p == player)
    #             increase_7 = next(inc for p, inc in first_degree if p == player)
    #             all_players.append(player)
    #             print(f"{player.name} had {increase_30:.2f} points above average over 30 days, {increase_15:.2f} points above average over 15 days, and {increase_7:.2f} points above average over 7 days \n")

    #     # self.hotStreakSingleReport(full_third_degree, all_players)
        
    #     print("Partial 3rd Degree Hot Streak:\n")
    #     self.hotStreakSingleReport(third_degree, all_players)

    #     print("Full Second Degree Hot Streak:\n")
    #     for player, increase_15 in full_second_degree:
    #         if player not in all_players:
    #             player_7 = next((p for p, inc in first_degree if p == player), None)
    #             if player_7:
    #                 increase_7 = next(inc for p, inc in first_degree if p == player)
    #                 all_players.append(player)
    #                 print(f"{player.name} had {increase_15:.2f} points above average over 15 days, and {increase_7:.2f} points above average over 7 days \n")

    #     # self.hotStreakSingleReport(full_second_degree, all_players)

    #     print("Partial 2nd Degree Hot Streak:\n")
    #     self.hotStreakSingleReport(second_degree, all_players)

    #     print("Full First Degree Hot Streak:\n")
    #     for player, increase_7 in first_degree:
    #         if player not in all_players:
    #             all_players.append(player)
    #             print(f"{player.name} had {increase_7:.2f} points above average over 7 days \n")

    #     title = ["1st Level Room Temp Players", "2nd Level Room Temp Players List", "3rd Level Room Temp Players List"]
    #     for i in range(2, -1, -1):
    #         print(f"{title[i]}:\n")
    #         self.hotStreakSingleReport(consistent[i], all_players)
        
    # def hotStreakSingleReport(self, streak_list, all_players):
    #     for index, player in enumerate(streak_list):
    #         player_obj = player[0]
    #         avg_points_increase = player[1]
    #         if player_obj in all_players:
    #             continue
    #         all_players.append(player_obj)
    #         print(f"{index+1}. {player_obj.name} with {avg_points_increase}\n")
    
    #     curr_code_streak = full_streak_ordering[code] 
        #     # self.streakPrintFormat(curr_code_streak)
        #     for player in curr_code_streak: 
        #         if code == "000":
        #             full_hot_3rd.append(player)
        #         if code[-2:] == "00" and code[-3] != "0":
        #             full_hot_2nd.append(player)
        #         if code[-1] == "0" and code[-2] != "0" and code[-3] != "0":
        #             full_hot_1st.append(player)
        #         if code == "111":
        #             full_cons_3rd.append(player)
        #         if code[-2:] == "11" and code[-3] != "1":
        #             full_cons_2nd.append(player)
        #         if code[-1] == "1" and code[-2] != "1" and code[-3] != "1":
        #             full_cons_1st.append(player)
        #         if code == "222":
        #             full_cold_3rd.append(player)
        #         if code[-2:] == "22" and code[-3] != "2":
        #             full_cold_2nd.append(player)
        #         if code[-1] == "2" and code[-2] != "2" and code[-3] != "2":
        #             full_cold_1st.append(player)

        #         if int(code[2]) == int(code[1]) + 1 and int(code[1]) == int(code[0]) + 1:
        #             heating_up.append(player)

        #         if int(code[0]) == int(code[1]) + 1 and int(code[1]) == int(code[2]) + 1:
        #             cooling_down_codes.append(code)

    Team.py

    # print("Testing Player Variables")
            # print(player.acquisitionType) # returns ADD, DRAFT, or TRADE
            # print(player.eligibleSlots) # returns [[Forward, Defense, Goalie,], [actual position of Forward], ['Util'] if F or D, ['Bench'], and [IR]
            # print(player.injured) # returns True if IR or OUT, not if DTD
            # print(player.injuryStatus) # returns ACTIVE if healthy, then returns DAY_TO_DAY, INJURY_RESERVE, SUSPENDED, or OUT
            # print(player.lineupSlot) # returns value from eligibleSlots of where player is currently located
            # print(player.playerId)
            # print(player.proTeam)
            # print(player.stats) # nested dictionaries that could be split. Inner Dictionaries: 'Total 2024' (prevYear), 'Total 2025' (currYear), 
            # 'Last 7 2025' stats from previous 7 games, 'Last 15 2025' stats from previous 15 games, 'Projected 2024' (prevYearProj), 'Projected 2025' (currYearProj)